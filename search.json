[{"path":"https://thomaszwagerman.github.io/butterfly/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 butterfly authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"installation","dir":"Articles","previous_headings":"","what":"Installation","title":"butterfly","text":"can install development version butterfly GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"thomaszwagerman/butterfly\")"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"overview","dir":"Articles","previous_headings":"","what":"Overview","title":"butterfly","text":"butterfly package contains following: butterfly::loupe() - examines detail whether previous values changed, returns TRUE/FALSE change/change. butterfly::catch() - returns rows contain previously changed values dataframe. butterfly::release() - drops rows contain previously changed values, returns dataframe containing new unchanged rows. butterfly::create_object_list() - returns list objects required loupe(), catch() release(). Contains underlying functionality. butterflycount - list monthly dataframes, contain fictional butterfly counts given date.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"how-to-use-butterfly","dir":"Articles","previous_headings":"","what":"How to use butterfly","title":"butterfly","text":"basic example shows use butterfly: can use butterfly::loupe() examine detail whether previous values changed. butterfly::loupe() uses dplyr::semi_join() match new old objects using common unique identifier, timeseries timestep. waldo::compare() used compare provide detailed report differences. butterfly follows waldo philosophy erring side providing much information, rather little. give detailed feedback message status two objects.","code":"library(butterfly)  # Imagine a continually updated dataset that starts in January and is updated once a month butterflycount$january #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11  # In February an additional row appears, all previous data remains the same butterflycount$february #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55 #> 4 2023-11-01    11  # In March an additional row appears again # ...but a previous value has unexpectedly changed butterflycount$march #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55 #> 5 2023-11-01    18 butterfly::loupe(   butterflycount$february,   butterflycount$january,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data. #> [1] TRUE  butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"using-butterfly-for-data-wrangling","dir":"Articles","previous_headings":"How to use butterfly","what":"Using butterfly for data wrangling","title":"butterfly","text":"might want return changed rows dataframe, drop altogether. butterfly::catch() butterfly::release() provided. , butterfly::catch() returns rows changed previous version. return new rows. Conversely, butterfly::release() drops rows changed previous version. Note retains new rows, expected.","code":"df_caught <- butterfly::catch(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ Only these rows are returned.  df_caught #>         time count #> 1 2023-11-01    18 df_released <- butterfly::release(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ These will be dropped, but new rows are included.  df_released #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"the-butterflycount-dataset","dir":"Articles","previous_headings":"","what":"The butterflycount dataset","title":"butterfly","text":"packages includes small dummy dataset, butterflycount, contains list monthly dataframes butterfly counts given date. dataset entirely fictional, merely included aid demonstrating butterfly’s functionality.","code":"butterflycount #> $january #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11 #>  #> $february #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55 #> 4 2023-11-01    11 #>  #> $march #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55 #> 5 2023-11-01    18 #>  #> $april #>         time value species #> 1 2024-04-01    12 Admiral #> 2 2024-03-01    23 Admiral #> 3 2024-02-01    NA Admiral #> 4 2024-01-01    22 Admiral #> 5 2023-12-01    55 Admiral #> 6 2023-11-01    18 Admiral"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"using-butterfly-in-a-data-processing-pipeline","dir":"Articles","previous_headings":"","what":"Using butterfly in a data processing pipeline","title":"butterfly","text":"like know using butterfly operational data processing pipeline, please refer article using butterfly operational pipeline.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"a-note-on-controlling-verbosity","dir":"Articles","previous_headings":"","what":"A note on controlling verbosity","title":"butterfly","text":"Although verbosity mostly purpose package, wish silence messages warnings, can options(rlib_message_verbosity = \"quiet\") options (rlib_warning_verbosity = \"quiet\").","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"rationale","dir":"Articles","previous_headings":"","what":"Rationale","title":"butterfly","text":"lot data comparison QA/QC packages , butterfly? package originally developed deal ERA5’s initial release data, ERA5T. ERA5T data month overwritten final ERA5 data two months month question. Usually ERA5 ERA5T identical, occasionally issue input data can (example 09/21 - 12/21, 07/24) force recalculation, meaning previously published data differs final product. publishing ERA5-derived datasets, minting DOI, possible continuously append without invalidating DOI. However, recalculation overwrite previously published data, thereby forcing new publication DOI minted. use functionality package automated data processing pipeline detect changes, stop data transfer notify user. package intentionally generalised accommodate , similar, use cases. examples include correction instrument calibration, compromised data transfer unnoticed changes parameterisation model.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"pipeline-overview","dir":"Articles","previous_headings":"","what":"Pipeline overview","title":"Using butterfly in an operational data pipeline","text":"Consider classic input/output (/O) data pipeline read data external source, perform sort calculation , transfer output different location. simple diagram showing steps generic data pipeline. use pipeline calculate ‘Amundsen Sea Low Index’, ASLI. Amundsen Seas Low (ASL) highly dynamic mobile climatological low pressure system located Pacific sector Southern Ocean. interested ASLI, values significant environmental forecasting, please refer Hosking et al. (2016). case, run pipeline monthly basis: diagram showing steps British Antarctic Survey data pipeline calculate publish Amundsen Sea Low Index dataset. generate ASLI dataset, read ERA5 mean sea level pressure, perform calculations using asli python package (Hosking & Wilby), move results UK Polar Data Centre (PDC), dataset published minted Digital Object Identifier (DOI). aim update dataset monthly basis, either appending new rows , re-writing dataset entirely. remember, change previous ERA5 data, also change results previous ASLI calculations. happened : overwrite dataset, changing values already-published dataset. append existing dataset, anyone attempting reproduce methods get different results. Either way, invalidate DOI force republication. Keeping --date Climate Data Store’s Forum monitor changes time-consuming task, reliable way detect changes.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"quality-assurance-using-butterfly-in-a-pipeline","dir":"Articles","previous_headings":"","what":"Quality assurance using butterfly in a pipeline","title":"Using butterfly in an operational data pipeline","text":"maintain integrity published dataset, need impose robust checks ensure new results match published data, expect . diagram showing steps British Antarctic Survey data pipeline calculate publish Amundsen Sea Low Index dataset, using butterfly check unexpected changes results. … butterfly comes . developing pipeline, separate data, configuration code.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"data","dir":"Articles","previous_headings":"Quality assurance using butterfly in a pipeline","what":"Data","title":"Using butterfly in an operational data pipeline","text":"purpose article, details dataset important. reference, subset ASLI dataset: subsequent month run pipeline , row added, new month ERA5 data since released. can see, data previous months also included data: submitted PDC.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"configuration","dir":"Articles","previous_headings":"Quality assurance using butterfly in a pipeline","what":"Configuration","title":"Using butterfly in an operational data pipeline","text":"Firstly let’s look configuration, stored ENVS file. determines locations input data, output data eventually publish data, among useful parameters:","code":"## Directories # Should not need editing, but you can do so if you wish # Location that pipeline is stored, referenced by most scripts export PIPELINE_DIRECTORY=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )  # Set input and output directories for downloaded files (DATA_DIR)  # And calculation results (OUTPUT_DIR) export DATA_DIR=${DATA_DIR:-${PIPELINE_DIRECTORY}/data/ERA5/monthly} export OUTPUT_DIR=${OUTPUT_DIR:-${PIPELINE_DIRECTORY}/output}  # Specify virtual environment so it does not need to be called prior to running export ASLI_VENV=${ASLI_VENV:-${PIPELINE_DIRECTORY}/asli_env/bin/activate}  # Setting rsync location, where we will eventually move our data should there  # Be no errors export RSYNC_LOCATION=\"\"  # Set dates and current year for iteration purposes export CURRENT_DATE=\"`date --utc +\"%Y_%m_%d\"`\" export CURRENT_YEAR=\"`date --utc +\"%Y\"`\"  ## Data querying parameters # ERA5 Downloading parameters, we are only selecting the current year, for the  # sake of computational efficiency export START_YEAR=2024 export END_YEAR=${CURRENT_YEAR} export DATA_ARGS_ERA5=\"-s ${START_YEAR} -n ${CURRENT_YEAR}\"  # FILE_IDENTIFIER will what the output filename is called # ie asli_calculation_$FILE_IDENTIFIER.csv # Depending on how you are organising your files, you might want this  # To be the CURRENT_YEAR, CURRENT_DATE or another unique ID export FILE_IDENTIFIER=${CURRENT_YEAR}"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"code","dir":"Articles","previous_headings":"Quality assurance using butterfly in a pipeline","what":"Code","title":"Using butterfly in an operational data pipeline","text":"Now set configuration, let’s inspect shell script actually runs pipeline, run_asli_pipeline.sh. concerns setting pipeline input output directories, well fetching environmental variables. Next calculation step, using functionality asli package: Lovely, now calculations ready $OUTPUT_DIR, rsync location given us PDC. first time, run: Let’s pretend first submission PDC. subsequent submission, want use butterfly compare new results file just submitted $RSYNC_LOCATION, make sure previous values changed.","code":"#!/bin/bash set -e  # Read in config file source ENVS  # Activate virtual environment source ${ASLI_VENV}  # Put all relevant directories in a list DIR_LIST=($DATA_DIR $OUTPUT_DIR)  # Create them if they do not exist for dir in ${DIR_LIST[@]}; do   if [ ! -d $dir ]; then     mkdir -p $dir     echo \"Created $dir\"   fi done # Fetch land sea mask, automatically writes in data directory # Everything is pre-set in asli functions, no arguments needed for our purpose asli_data_lsm  # Downloading latest ERA5 data, provide information to the user echo \"Requesting with the following arguments: $DATA_ARGS_ERA5\". asli_data_era5 $DATA_ARGS_ERA5  # Run calculation, specifying output location asli_calc $DATA_DIR/era5_mean_sea_level_pressure_monthly_*.nc -o $OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv rsync $OUTPUT_DIR/*.csv $RSYNC_LOCATION echo \"Writing to $RSYNC_LOCATION.\""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"incorporate-r-and-butterfly-into-a-shell-scripted-pipeline","dir":"Articles","previous_headings":"Quality assurance using butterfly in a pipeline > Code","what":"Incorporate R and butterfly into a shell-scripted pipeline","title":"Using butterfly in an operational data pipeline","text":"going implement R script called quality_control.R, provide new calculations calculations previously transferred $RSYNC_LOCATION, like: , $OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv recent calculation, quality_control.R referred args[1]. previous calculation, $RSYNC_LOCATION/asli_calculation_$FILE_IDENTIFIER.csv, args[2]. Let’s look quality_control.R now. started making script executable shell, provide user instructions use script, obtaining arguments given args. Next, test arguments actually provided, read files: Great! Now files read , can start quality assurance using butterfly. case, use butterfly::loupe() give us report, return either TRUE (previous data changed, happy proceed) FALSE (change previous data detected, abort data transfer). last check, (!isTRUE(qa_outcome)) trigger stop entire pipeline change detected.","code":"Rscript quality_control.R \"$OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv\" \"$RSYNC_LOCATION/asli_calculation_$FILE_IDENTIFIER.csv\" #!/usr/bin/env Rscript # Usage: Rscript 02_quality_control.R <current-file-path> <existing-file-path>  # Obtain passed arguments args = commandArgs(trailingOnly=TRUE) # Test if there is two arguments: the output and previous file if (length(args)!=2) {   stop(     \"Please provide the output file, and the file it is being compared to\", call.=FALSE   ) } else {  current_output <- readr::read_csv(   args[1] )  existing_file <- readr::read_csv(   args[2] )  } # Use butterfly to check there are no changes to past data qa_outcome <- butterfly::loupe(   current_output,   existing_file,   datetime_variable = \"time\" )  if (!isTRUE(qa_outcome)) {   stop(     \"Previous values do not match. Stopping data transfer.\"   ) }"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"the-whole-game","dir":"Articles","previous_headings":"","what":"The whole game","title":"Using butterfly in an operational data pipeline","text":"’ve inspected every bit functionality pipeline, can summarised : Reading data, calculating asli values, putting results output folder. Running quality assurance checks results output folder, comparing rsync location. Transferring results output folder rsync location, quality assurance checks passed. sensible way organising distinct steps pipeline, move different components functionality script. case : 01_run_asli_calculations.sh 02_quality_control.R 03_export_file_to_pdc.sh. Finally, let’s update run_asli_pipeline.sh make easier read. ! Importantly, 02_quality_control.R run 03_export_file_to_pdc.sh. cli::cat_*() warnings used butterfly, print shell automatically allow diagnose differences might occurred. cli::cat_abort() automatically stop pipeline. Therefore, failure 02_quality_control.R prevent data reaching destination.","code":"#!/bin/bash set -e  # Read in config file source ENVS  # Activate virtual environment source ${ASLI_VENV}  # Put all relevant directories in a list DIR_LIST=($DATA_DIR $OUTPUT_DIR)  # Create them if they do not exist for dir in ${DIR_LIST[@]}; do   if [ ! -d $dir ]; then     mkdir -p $dir     echo \"Created $dir\"   fi done  # Run calculations, writes an output file in $OUTPUT_DIR bash 01_run_asli_calculations.sh  # Check whether our new data has any changes from previously submitted data Rscript 02_quality_control.R \"$OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv\" \"$RSYNC_LOCATION/asli_calculation_$FILE_IDENTIFIER.csv\"  # If successfuly, export our data to the PDC bash 03_export_file_to_pdc.sh"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"so-whats-next","dir":"Articles","previous_headings":"","what":"So what’s next?","title":"Using butterfly in an operational data pipeline","text":", butterfly job, detected changes stopped data transfer… now ? Currently, set warn user, can intervene process manually. next step make published data static, now longer appending . supersede new data, restart process. future aim however, automatically: diagram showing next steps automated data processing publishing pipeline, incorporating automated archival supserceding. lot complex handle however, especially considering currently DOIs minted manually, regardless data state. Perhaps form human intervention always required, one can dream!","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Using butterfly in an operational data pipeline","text":"Hosking, J. S., . Orr, T. J. Bracegirdle, J. Turner (2016), Future circulation changes West Antarctica: Sensitivity Amundsen Sea Low projected anthropogenic forcing, Geophys. Res. Lett., 43, 367–376, doi:10.1002/2015GL067143. Hosking, J. S., & Wilby, D. asli [Computer software]. https://github.com/scotthosking/amundsen-sea-low-index Zwagerman, T., & Wilby, D. asli-pipeline [Computer software]. https://github.com/antarctica/boost-eds-pipeline","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thomas Zwagerman. Author, maintainer.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thomas Z (2024). “butterfly: quality assurance continually updating overwritten time-series data.”","code":"@Misc{,   title = {{butterfly}: quality assurance of continually updating and overwritten time-series data},   author = {Zwagerman Thomas},   year = {2024}, }"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"butterfly-","dir":"","previous_headings":"","what":"QA/QC For Continually Updating Timeseries Data","title":"QA/QC For Continually Updating Timeseries Data","text":"goal butterfly aid quality assurance continually updating overwritten time-series data, expect new values time, want ensure previous data remains unchanged. illustration continually updating timeseries data previous value unexpectedly changes. Data previously recorded change number reasons, discovery error model code, change methodology instrument recalibration. Monitoring data sources changes always possible. Unnoticed changes previous data unintended consequences, invalidating DOIs, altering future predictions used input forecasting models. package provides functionality can used part data pipeline, check flag changes previous data prevent changes going unnoticed.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"QA/QC For Continually Updating Timeseries Data","text":"can install development version butterfly GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"thomaszwagerman/butterfly\")"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"QA/QC For Continually Updating Timeseries Data","text":"butterfly package contains following: butterfly::loupe() - examines detail whether previous values changed, returns TRUE/FALSE change/change. butterfly::catch() - returns rows contain previously changed values dataframe. butterfly::release() - drops rows contain previously changed values, returns dataframe containing new unchanged rows. butterfly::create_object_list() - returns list objects required loupe(), catch() release(). Contains underlying functionality. butterflycount - list monthly dataframes, contain fictional butterfly counts given date.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"QA/QC For Continually Updating Timeseries Data","text":"basic example shows use butterfly: can use butterfly::loupe() examine detail whether previous values changed. butterfly::loupe() uses dplyr::semi_join() match new old objects using common unique identifier, timeseries timestep. waldo::compare() used compare provide detailed report differences. butterfly follows waldo philosophy erring side providing much information, rather little. give detailed feedback message status two objects.","code":"library(butterfly)  # Imagine a continually updated dataset that starts in January and is updated once a month butterflycount$january #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11  # In February an additional row appears, all previous data remains the same butterflycount$february #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55 #> 4 2023-11-01    11  # In March an additional row appears again # ...but a previous value has unexpectedly changed butterflycount$march #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55 #> 5 2023-11-01    18 butterfly::loupe(   butterflycount$february,   butterflycount$january,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data. #> [1] TRUE  butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"using-butterfly-for-data-wrangling","dir":"","previous_headings":"Examples","what":"Using butterfly for data wrangling","title":"QA/QC For Continually Updating Timeseries Data","text":"might want return changed rows dataframe, drop altogether. butterfly::catch() butterfly::release() provided. , butterfly::catch() returns rows changed previous version. return new rows. Conversely, butterfly::release() drops rows changed previous version. Note retains new rows, expected.","code":"df_caught <- butterfly::catch(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ Only these rows are returned.  df_caught #>         time count #> 1 2023-11-01    18 df_released <- butterfly::release(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ These will be dropped, but new rows are included.  df_released #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"relevant-packages-and-functions","dir":"","previous_headings":"","what":"Relevant packages and functions","title":"QA/QC For Continually Updating Timeseries Data","text":"butterfly package created specific use case handling continuously updating/overwritten time-series data, previous values may change without notice. R packages functions handle object comparison, may suit specific needs better: waldo diffdf assertr daquiri functions include .equal() dplyr’s setdiff()","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterfly-package.html","id":null,"dir":"Reference","previous_headings":"","what":"butterfly: QA/QC For Continually Updating Timeseries Data — butterfly-package","title":"butterfly: QA/QC For Continually Updating Timeseries Data — butterfly-package","text":"QA/QC continually updating timeseries data expect new values, want ensure previous data remains unchanged.","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterfly-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"butterfly: QA/QC For Continually Updating Timeseries Data — butterfly-package","text":"Maintainer: Thomas Zwagerman thozwa@bas.ac.uk (ORCID)","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterflycount.html","id":null,"dir":"Reference","previous_headings":"","what":"Butterfly count dummy data — butterflycount","title":"Butterfly count dummy data — butterflycount","text":"completely fictional dataset monthly butterfly counts","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterflycount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Butterfly count dummy data — butterflycount","text":"","code":"butterflycount"},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterflycount.html","id":"butterflycount","dir":"Reference","previous_headings":"","what":"butterflycount","title":"Butterfly count dummy data — butterflycount","text":"list 4 dataframes (january, february, march, april) containing 3 columns, 3 + n_month rows: time date imaginary count took place, yyyy-mm-dd format count Number fictional butterflies counted species Butterfly species name, appears april","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":null,"dir":"Reference","previous_headings":"","what":"Catch: return dataframe containing only rows that have changed — catch","title":"Catch: return dataframe containing only rows that have changed — catch","text":"function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries), returns new dataframe contains rows changed compared previous data. return new rows.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Catch: return dataframe containing only rows that have changed — catch","text":"","code":"catch(df_current, df_previous, datetime_variable)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Catch: return dataframe containing only rows that have changed — catch","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable character, variable use unique ID join df_current df_previous. Usually \"datetime\" variable.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Catch: return dataframe containing only rows that have changed — catch","text":"dataframe contains rows df_current changes df_previous, without new rows. also returns waldo object loupe().","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Catch: return dataframe containing only rows that have changed — catch","text":"underlying functionality handled create_object_list().","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Catch: return dataframe containing only rows that have changed — catch","text":"","code":"df_caught <- butterfly::catch(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ Only these rows are returned.  df_caught #>         time count #> 1 2023-11-01    18"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":null,"dir":"Reference","previous_headings":"","what":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"function creates list objects used loupe(), catch() release().","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"","code":"create_object_list(df_current, df_previous, datetime_variable)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"list containing boolean TRUE indicates changes previous data FALSE indicates unexpected changes, dataframe current data without new rows dataframe new rows ","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries). informs user new (unmatched) rows appeared, returns waldo::compare() call give detailed breakdown changes. main assumption df_current df_previous newer older versions data, datetime_variable variable name always remains . Elsewhere new columns can appear, returned report.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"","code":"butterfly_object_list <- butterfly::create_object_list(   butterflycount$february,   butterflycount$january,   datetime_variable = \"time\" ) #> The following rows are new in 'butterflycount$february':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data.  butterfly_object_list #> $butterfly_status #> [1] TRUE #>  #> $df_current_without_new_row #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11 #>  #> $df_current_new_rows #>         time count #> 1 2024-02-01    17 #>"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":null,"dir":"Reference","previous_headings":"","what":"Loupe: compare new and old data in continuously updated timeseries — loupe","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"loupe simple, small magnification device used examine small details closely.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"","code":"loupe(df_current, df_previous, datetime_variable)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"boolean TRUE indicates changes previous data FALSE indicates unexpected changes.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"function intended aid quality assurance continually updating timeseries data expect new values want ensure previous values remains unchanged. function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries). informs user new (unmatched) rows appeared, returns waldo::compare() call give detailed breakdown changes. main assumption df_current df_previous newer older versions data, datetime_variable variable name always remains . Elsewhere new columns can appear, returned report. underlying functionality handled create_object_list().","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"","code":"# This example contains no differences with previous data butterfly::loupe(   butterflycount$february,   butterflycount$january,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data. #> [1] TRUE  # This example does contain differences with previous data butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":null,"dir":"Reference","previous_headings":"","what":"Release: return current dataframe without changed old rows — release","title":"Release: return current dataframe without changed old rows — release","text":"function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries), returns new dataframe contains new rows (present) matched rows contain changes previous data dropped.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Release: return current dataframe without changed old rows — release","text":"","code":"release(df_current, df_previous, datetime_variable, include_new = TRUE)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Release: return current dataframe without changed old rows — release","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable. include_new boolean, new rows included? Default TRUE.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Release: return current dataframe without changed old rows — release","text":"dataframe contains rows df_current changed df_previous, includes new rows. also returns waldo object loupe().","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Release: return current dataframe without changed old rows — release","text":"","code":"df_released <- butterfly::release(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ These will be dropped, but new rows are included.  df_released #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55"}]
