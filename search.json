[{"path":"https://thomaszwagerman.github.io/butterfly/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to butterfly","title":"Contributing to butterfly","text":"outlines propose change butterfly. detailed discussion contributing tidyverse packages, please see development contributing guide code review principles.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/CONTRIBUTING.html","id":"fixing-typos","dir":"","previous_headings":"","what":"Fixing typos","title":"Contributing to butterfly","text":"can fix typos, spelling mistakes, grammatical errors documentation directly using GitHub web interface, long changes made source file. generally means ’ll need edit roxygen2 comments .R, .Rd file. can find .R file generates .Rd reading comment first line.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/CONTRIBUTING.html","id":"bigger-changes","dir":"","previous_headings":"","what":"Bigger changes","title":"Contributing to butterfly","text":"want make bigger change, ’s good idea first file issue make sure someone team agrees ’s needed. ’ve found bug, please file issue illustrates bug minimal reprex (also help write unit test, needed). See guide create great issue advice.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/CONTRIBUTING.html","id":"pull-request-process","dir":"","previous_headings":"Bigger changes","what":"Pull request process","title":"Contributing to butterfly","text":"Fork package clone onto computer. haven’t done , recommend using usethis::create_from_github(\"thomaszwagerman/butterfly\", fork = TRUE). Install development dependencies devtools::install_dev_deps(), make sure package passes R CMD check running devtools::check(). R CMD check doesn’t pass cleanly, ’s good idea ask help continuing. Create Git branch pull request (PR). recommend using usethis::pr_init(\"brief-description--change\"). Make changes, commit git, create PR running usethis::pr_push(), following prompts browser. title PR briefly describe change. body PR contain Fixes #issue-number. user-facing changes, add bullet top NEWS.md (.e. just first header). Follow style described https://style.tidyverse.org/news.html.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/CONTRIBUTING.html","id":"code-style","dir":"","previous_headings":"Bigger changes","what":"Code style","title":"Contributing to butterfly","text":"New code follow tidyverse style guide. can use styler package apply styles, please don’t restyle code nothing PR. use roxygen2, Markdown syntax, documentation. use testthat unit tests. Contributions test cases included easier accept.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to butterfly","text":"Please note butterfly project released Contributor Code Conduct. contributing project agree abide terms.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/LICENSE.html","id":null,"dir":"","previous_headings":"","what":"MIT License","title":"MIT License","text":"Copyright (c) 2024 butterfly authors Permission hereby granted, free charge, person obtaining copy software associated documentation files (“Software”), deal Software without restriction, including without limitation rights use, copy, modify, merge, publish, distribute, sublicense, /sell copies Software, permit persons Software furnished , subject following conditions: copyright notice permission notice shall included copies substantial portions Software. SOFTWARE PROVIDED “”, WITHOUT WARRANTY KIND, EXPRESS IMPLIED, INCLUDING LIMITED WARRANTIES MERCHANTABILITY, FITNESS PARTICULAR PURPOSE NONINFRINGEMENT. EVENT SHALL AUTHORS COPYRIGHT HOLDERS LIABLE CLAIM, DAMAGES LIABILITY, WHETHER ACTION CONTRACT, TORT OTHERWISE, ARISING , CONNECTION SOFTWARE USE DEALINGS SOFTWARE.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"butterfly","text":"packages includes small dummy dataset, butterflycount, contains list monthly dataframes butterfly counts given date. dataset entirely fictional, merely included aid demonstrating butterfly’s functionality.","code":"library(butterfly) butterflycount #> $january #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11 #>  #> $february #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55 #> 4 2023-11-01    11 #>  #> $march #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55 #> 5 2023-11-01    18 #>  #> $april #>         time value species #> 1 2024-04-01    12 Admiral #> 2 2024-03-01    23 Admiral #> 3 2024-02-01    NA Admiral #> 4 2024-01-01    22 Admiral #> 5 2023-12-01    55 Admiral #> 6 2023-11-01    18 Admiral #>  #> $may #>         time value species #> 1 2024-05-01    70 Admiral #> 2 2024-04-01    12 Admiral #> 3 2024-03-01    23 Admiral #> 4 2024-01-01    22 Admiral #> 5 2024-12-01    55 Admiral #> 6 2024-11-01    18 Admiral"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"examining-datasets-loupe","dir":"Articles","previous_headings":"","what":"Examining datasets: loupe()","title":"butterfly","text":"can use butterfly::loupe() examine detail whether previous values changed. butterfly::loupe() uses dplyr::semi_join() match new old objects using common unique identifier, timeseries timestep. waldo::compare() used compare provide detailed report differences. butterfly follows waldo philosophy erring side providing much information, rather little. give detailed feedback message status two objects.","code":"butterfly::loupe(   butterflycount$february,   butterflycount$january,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data. #> [1] TRUE  butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"additional-arguments-from-waldocompare","dir":"Articles","previous_headings":"Examining datasets: loupe()","what":"Additional arguments from waldo::compare()","title":"butterfly","text":"flexibility pass arguments waldo::compare() accepts, butterfly function, instance specify tolerance. add tolerance 2 previous example, differences returned: Call ?waldo::compare() see full list arguments.","code":"butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\",   tolerance = 2 # <- setting a tolerance of 2 ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #> ✔ And there are no differences with previous data. #> [1] TRUE"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"extracting-unexpected-changes-catch","dir":"Articles","previous_headings":"","what":"Extracting unexpected changes: catch()","title":"butterfly","text":"might want return changed rows dataframe. butterfly::catch()provided. butterfly::catch() returns rows changed previous version. return new rows.","code":"df_caught <- butterfly::catch(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #>  #> ℹ Only these rows are returned.  df_caught #>         time count #> 1 2023-11-01    18"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"dropping-unexpected-changes-release","dir":"Articles","previous_headings":"","what":"Dropping unexpected changes: release()","title":"butterfly","text":"Conversely, butterfly::release() drops rows changed previous version. Note retains new rows, expected. However, option exclude new rows well argument include_new set FALSE.","code":"df_released <- butterfly::release(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #>  #> ℹ These will be dropped, but new rows are included.  df_released #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55 df_release_without_new <- butterfly::release(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\",   include_new = FALSE ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #>  #> ℹ These will be dropped, along with new rows.  df_release_without_new #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"checking-for-continuity-timeline","dir":"Articles","previous_headings":"","what":"Checking for continuity: timeline()","title":"butterfly","text":"check timeseries continuous, timeline() timeline_group() provided. Even timeseries contain obvious gaps, automatically mean also continuous. Measuring instruments can different behaviours fail. example, power failure internal clock reset “1970-01-01”, manufacturing date (say, “2021-01-01”). leads unpredictable ways checking dataset continuous. check timeseries continuous: nice continuous dataset, difference 1 day timesteps. However, February imaginary rain gauge’s onboard computer failure. timestamp reset 1970-01-01:","code":"butterfly::timeline(    forestprecipitation$january,    datetime_variable = \"time\",    expected_lag = 1  ) #> ✔ There are no time lags which are greater than the expected lag: 1 days. By this measure, the timeseries is continuous. #> [1] TRUE forestprecipitation$february #>                  time rainfall_mm #> 1 2024-02-01 00:00:00         1.1 #> 2 2024-02-02 00:00:00         0.0 #> 3 2024-02-03 00:00:00         1.4 #> 4 2024-02-04 00:00:00         2.2 #> 5 1969-12-31 23:00:00         3.4 #> 6 1970-01-01 23:00:00         0.6  butterfly::timeline(   forestprecipitation$february,    datetime_variable = \"time\",    expected_lag = 1  ) #> ℹ There are time lags which are greater than the expected lag: 1 days. This indicates the timeseries is not continuous. There are 2 distinct continuous sequences. Use `timeline_group()` to extract. #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"grouping-distinct-continuous-sequences-timeline_group","dir":"Articles","previous_headings":"","what":"Grouping distinct continuous sequences: timeline_group()","title":"butterfly","text":"wanted group chunks timeseries distinct, broken way, still continuous, can use timeline_group(): now groups 1 & 2, continuous sets data, continuity .","code":"butterfly::timeline_group(   forestprecipitation$february,    datetime_variable = \"time\",    expected_lag = 1  ) #>                  time rainfall_mm        timelag timeline_group #> 1 2024-02-01 00:00:00         1.1        NA days              1 #> 2 2024-02-02 00:00:00         0.0      1.00 days              1 #> 3 2024-02-03 00:00:00         1.4      1.00 days              1 #> 4 2024-02-04 00:00:00         2.2      1.00 days              1 #> 5 1969-12-31 23:00:00         3.4 -19757.04 days              2 #> 6 1970-01-01 23:00:00         0.6      1.00 days              2"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"using-butterfly-in-a-data-processing-pipeline","dir":"Articles","previous_headings":"","what":"Using butterfly in a data processing pipeline","title":"butterfly","text":"like know using butterfly operational data processing pipeline, please refer article using butterfly operational pipeline.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"a-note-on-controlling-verbosity","dir":"Articles","previous_headings":"","what":"A note on controlling verbosity","title":"butterfly","text":"Although verbosity mostly purpose package, wish silence messages warnings, can options(rlib_message_verbosity = \"quiet\") options (rlib_warning_verbosity = \"quiet\").","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly.html","id":"rationale","dir":"Articles","previous_headings":"","what":"Rationale","title":"butterfly","text":"lot data comparison QA/QC packages , butterfly? package originally developed deal ERA5’s initial release data, ERA5T. ERA5T data month overwritten final ERA5 data two months month question. Usually ERA5 ERA5T identical, occasionally issue input data can (example 09/21 - 12/21, 07/24) force recalculation, meaning previously published data differs final product. publishing ERA5-derived datasets, minting DOI, possible continuously append without invalidating DOI. However, recalculation overwrite previously published data, thereby forcing new publication DOI minted. use functionality package automated data processing pipeline detect changes, stop data transfer notify user. package intentionally generalised accommodate , similar, use cases. examples include correction instrument calibration, compromised data transfer unnoticed changes parameterisation model.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"pipeline-overview","dir":"Articles","previous_headings":"","what":"Pipeline overview","title":"Using butterfly in an operational data pipeline","text":"Consider classic input/output (/O) data pipeline read data external source, perform sort calculation , transfer output different location. simple diagram showing steps generic data pipeline. use pipeline calculate ‘Amundsen Sea Low Index’, ASLI. Amundsen Seas Low (ASL) highly dynamic mobile climatological low pressure system located Pacific sector Southern Ocean. interested ASLI, values significant environmental forecasting, please refer Hosking et al. (2016). case, run pipeline monthly basis: diagram showing steps British Antarctic Survey data pipeline calculate publish Amundsen Sea Low Index dataset. generate ASLI dataset, read ERA5 mean sea level pressure, perform calculations using asli python package (Hosking & Wilby), move results UK Polar Data Centre (PDC), dataset published minted Digital Object Identifier (DOI). aim update dataset monthly basis, either appending new rows , re-writing dataset entirely. remember, change previous ERA5 data, also change results previous ASLI calculations. happened : overwrite dataset, changing values already-published dataset. append existing dataset, anyone attempting reproduce methods get different results. Either way, invalidate DOI force republication. Keeping --date Climate Data Store’s Forum monitor changes time-consuming task, reliable way detect changes.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"verification-using-butterfly-in-a-pipeline","dir":"Articles","previous_headings":"","what":"Verification using butterfly in a pipeline","title":"Using butterfly in an operational data pipeline","text":"maintain integrity published dataset, need impose robust checks ensure new results match published data, expect . diagram showing steps British Antarctic Survey data pipeline calculate publish Amundsen Sea Low Index dataset, using butterfly check unexpected changes results. … butterfly comes . developing pipeline, separate data, configuration code.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"data","dir":"Articles","previous_headings":"Verification using butterfly in a pipeline","what":"Data","title":"Using butterfly in an operational data pipeline","text":"purpose article, details dataset important. reference, subset ASLI dataset: subsequent month run pipeline , row added, new month ERA5 data since released. can see, data previous months also included data: submitted PDC.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"configuration","dir":"Articles","previous_headings":"Verification using butterfly in a pipeline","what":"Configuration","title":"Using butterfly in an operational data pipeline","text":"Firstly let’s look configuration, stored ENVS file. determines locations input data, output data eventually publish data, among useful parameters:","code":"## Directories # Should not need editing, but you can do so if you wish # Location that pipeline is stored, referenced by most scripts export PIPELINE_DIRECTORY=$( cd -- \"$( dirname -- \"${BASH_SOURCE[0]}\" )\" &> /dev/null && pwd )  # Set input and output directories for downloaded files (DATA_DIR)  # And calculation results (OUTPUT_DIR) export DATA_DIR=${DATA_DIR:-${PIPELINE_DIRECTORY}/data/ERA5/monthly} export OUTPUT_DIR=${OUTPUT_DIR:-${PIPELINE_DIRECTORY}/output}  # Specify virtual environment so it does not need to be called prior to running export ASLI_VENV=${ASLI_VENV:-${PIPELINE_DIRECTORY}/asli_env/bin/activate}  # Setting rsync location, where we will eventually move our data should there  # Be no errors export RSYNC_LOCATION=\"\"  # Set dates and current year for iteration purposes export CURRENT_DATE=\"`date --utc +\"%Y_%m_%d\"`\" export CURRENT_YEAR=\"`date --utc +\"%Y\"`\"  ## Data querying parameters # ERA5 Downloading parameters, we are only selecting the current year, for the  # sake of computational efficiency export START_YEAR=2024 export END_YEAR=${CURRENT_YEAR} export DATA_ARGS_ERA5=\"-s ${START_YEAR} -n ${CURRENT_YEAR}\"  # FILE_IDENTIFIER will what the output filename is called # ie asli_calculation_$FILE_IDENTIFIER.csv # Depending on how you are organising your files, you might want this  # To be the CURRENT_YEAR, CURRENT_DATE or another unique ID export FILE_IDENTIFIER=${CURRENT_YEAR}"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"code","dir":"Articles","previous_headings":"Verification using butterfly in a pipeline","what":"Code","title":"Using butterfly in an operational data pipeline","text":"Now set configuration, let’s inspect shell script actually runs pipeline, run_asli_pipeline.sh. concerns setting pipeline input output directories, well fetching environmental variables. Next calculation step, using functionality asli package: Lovely, now calculations ready $OUTPUT_DIR, rsync location given us PDC. first time, run: Let’s pretend first submission PDC. subsequent submission, want use butterfly compare new results file just submitted $RSYNC_LOCATION, make sure previous values changed.","code":"#!/bin/bash set -e  # Read in config file source ENVS  # Activate virtual environment source ${ASLI_VENV}  # Put all relevant directories in a list DIR_LIST=($DATA_DIR $OUTPUT_DIR)  # Create them if they do not exist for dir in ${DIR_LIST[@]}; do   if [ ! -d $dir ]; then     mkdir -p $dir     echo \"Created $dir\"   fi done # Fetch land sea mask, automatically writes in data directory # Everything is pre-set in asli functions, no arguments needed for our purpose asli_data_lsm  # Downloading latest ERA5 data, provide information to the user echo \"Requesting with the following arguments: $DATA_ARGS_ERA5\". asli_data_era5 $DATA_ARGS_ERA5  # Run calculation, specifying output location asli_calc $DATA_DIR/era5_mean_sea_level_pressure_monthly_*.nc -o $OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv rsync $OUTPUT_DIR/*.csv $RSYNC_LOCATION echo \"Writing to $RSYNC_LOCATION.\""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"incorporate-r-and-butterfly-into-a-shell-scripted-pipeline","dir":"Articles","previous_headings":"Verification using butterfly in a pipeline > Code","what":"Incorporate R and butterfly into a shell-scripted pipeline","title":"Using butterfly in an operational data pipeline","text":"going implement R script called quality_control.R, provide new calculations calculations previously transferred $RSYNC_LOCATION, like: , $OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv recent calculation, quality_control.R referred args[1]. previous calculation, $RSYNC_LOCATION/asli_calculation_$FILE_IDENTIFIER.csv, args[2]. Let’s look quality_control.R now. started making script executable shell, provide user instructions use script, obtaining arguments given args. Next, test arguments actually provided, read files: Great! Now files read , can start verification using butterfly. case, use butterfly::loupe() give us report, return either TRUE (previous data changed, happy proceed) FALSE (change previous data detected, abort data transfer). last check, (!isTRUE(qa_outcome)) trigger stop entire pipeline change detected.","code":"Rscript quality_control.R \"$OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv\" \"$RSYNC_LOCATION/asli_calculation_$FILE_IDENTIFIER.csv\" #!/usr/bin/env Rscript # Usage: Rscript 02_quality_control.R <current-file-path> <existing-file-path>  # Obtain passed arguments args = commandArgs(trailingOnly=TRUE) # Test if there is two arguments: the output and previous file if (length(args)!=2) {   stop(     \"Please provide the output file, and the file it is being compared to\", call.=FALSE   ) } else {  current_output <- readr::read_csv(   args[1] )  existing_file <- readr::read_csv(   args[2] )  } # Use butterfly to check there are no changes to past data qa_outcome <- butterfly::loupe(   current_output,   existing_file,   datetime_variable = \"time\" )  if (!isTRUE(qa_outcome)) {   stop(     \"Previous values do not match. Stopping data transfer.\"   ) }"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"the-whole-game","dir":"Articles","previous_headings":"","what":"The whole game","title":"Using butterfly in an operational data pipeline","text":"’ve inspected every bit functionality pipeline, can summarised : Reading data, calculating asli values, putting results output folder. Running verification checks results output folder, comparing rsync location. Transferring results output folder rsync location, verification checks passed. sensible way organising distinct steps pipeline, move different components functionality script. case : 01_run_asli_calculations.sh 02_quality_control.R 03_export_file_to_pdc.sh. Finally, let’s update run_asli_pipeline.sh make easier read. ! Importantly, 02_quality_control.R run 03_export_file_to_pdc.sh. cli::cat_*() warnings used butterfly, print shell automatically allow diagnose differences might occurred. cli::cat_abort() automatically stop pipeline. Therefore, failure 02_quality_control.R prevent data reaching destination.","code":"#!/bin/bash set -e  # Read in config file source ENVS  # Activate virtual environment source ${ASLI_VENV}  # Put all relevant directories in a list DIR_LIST=($DATA_DIR $OUTPUT_DIR)  # Create them if they do not exist for dir in ${DIR_LIST[@]}; do   if [ ! -d $dir ]; then     mkdir -p $dir     echo \"Created $dir\"   fi done  # Run calculations, writes an output file in $OUTPUT_DIR bash 01_run_asli_calculations.sh  # Check whether our new data has any changes from previously submitted data Rscript 02_quality_control.R \"$OUTPUT_DIR/asli_calculation_$FILE_IDENTIFIER.csv\" \"$RSYNC_LOCATION/asli_calculation_$FILE_IDENTIFIER.csv\"  # If successfuly, export our data to the PDC bash 03_export_file_to_pdc.sh"},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"so-whats-next","dir":"Articles","previous_headings":"","what":"So what’s next?","title":"Using butterfly in an operational data pipeline","text":", butterfly job, detected changes stopped data transfer… now ? Currently, set warn user, can intervene process manually. next step make published data static, now longer appending . supersede new data, restart process. future aim however, automatically: diagram showing next steps automated data processing publishing pipeline, incorporating automated archival supserceding. lot complex handle however, especially considering currently DOIs minted manually, regardless data state. Perhaps form human intervention always required, one can dream!","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_in_pipeline.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Using butterfly in an operational data pipeline","text":"Hosking, J. S., . Orr, T. J. Bracegirdle, J. Turner (2016), Future circulation changes West Antarctica: Sensitivity Amundsen Sea Low projected anthropogenic forcing, Geophys. Res. Lett., 43, 367–376, doi:10.1002/2015GL067143. Hosking, J. S., & Wilby, D. asli [Computer software]. https://github.com/scotthosking/amundsen-sea-low-index Zwagerman, T., & Wilby, D. asli-pipeline [Computer software]. https://github.com/antarctica/boost-eds-pipeline","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_paper.html","id":"summary","dir":"Articles","previous_headings":"","what":"Summary","title":"butterfly: An R package for the verification of continually updating timeseries data where we expect new values, but want to ensure previous data remains unchanged.","text":"Previously recorded data revised initial publication number reasons, discovery inconsistency error, change methodology instrument re-calibration. using data generate , crucial reference exact version data used, order maintain data provenance. Unnoticed changes previous data unintended consequences, invalidating published dataset’s Digital Object Identfier (DOI), altering future predictions used input forecasting models. aware upstream changes input data? Monitoring data sources changes always possible. present butterfly, R package verification continually updating timeseries data expect new values, want ensure previous data remains unchanged. intention butterfly check changes previously published data, warn user report contains much details possible. allow stop unintended data transfer, revise published data, release new version communicate significance change users.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_paper.html","id":"statement-of-need","dir":"Articles","previous_headings":"","what":"Statement of Need","title":"butterfly: An R package for the verification of continually updating timeseries data where we expect new values, but want to ensure previous data remains unchanged.","text":"Importance citing exact extract data (Klump et al. 2021) Semantic versioning widely adopted research software (Preston-Werner 2013) Generating derived data product key recommendation Siddorn et al.’s (2022) report “Information Management Framework Environmental Digital Twins (IMFe)… data provenance must maintained data quality frameworks clearly documented users available machine-readable format tools methods … FAIR implementation (Wilkinson et al. 2016). British Antarctic Survey (BAS), developed package deal specific issue. Quality assurance continually updating continually published ERA5-derived data. BAS, frequently use ERA5 (Hersbach et al. 2023) input climate models. IceNet sea ice prediction system based deep learning (Andersson et al. 2021) ERA5-derived data.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_paper.html","id":"the-issue-with-era5-and-era5-interim","dir":"Articles","previous_headings":"Statement of Need","what":"The issue with ERA5 and ERA5-Interim","title":"butterfly: An R package for the verification of continually updating timeseries data where we expect new values, but want to ensure previous data remains unchanged.","text":"package originally developed deal ERA5’s initial release data, ERA5T. ERA5T data month overwritten final ERA5 data two months month question. Usually ERA5 ERA5T identical, occasionally issue input data can (example 09/21 - 12/21, 07/24) force recalculation, meaning previously published data differs final product. cases, issue. static data publications snapshot time, data associated specific paper, “Forecasts, neural networks, results paper: ‘Seasonal Arctic sea ice forecasting probabilistic deep learning’” Andersson & Hosking (2021)[@Andersson_2021] time period “Downscaled ERA5 monthly precipitation data using Multi-Fidelity Gaussian Processes 1980 2012 Upper Beas Sutlej Basins, Himalaya” Tazi (2023), issue. datasets clearly describe version time period ERA5 data derived, amended updated future, even ERA5 recalculated. case however want continually append ERA5-derived datasets continually publish . useful functioning data source environmental digital twin (Blair & Hnerys et al. 2023), simply input data environmental forecasting model frequently running. Continually appending publishing require strict quality assurance. published dataset appended DOI can minted .  However, previously published data change, invalidate DOI.  example, developed code find better measure (accurate, precise) low pressure region, wanted reanalyse previous data republish. One ERA5-derived dataset (hopefully soon!) publish BAS Amundsen Sea Low Index (ASLI).","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_paper.html","id":"what-is-the-amundsen-sea-low-index","dir":"Articles","previous_headings":"Statement of Need","what":"What is the Amundsen Sea Low Index","title":"butterfly: An R package for the verification of continually updating timeseries data where we expect new values, but want to ensure previous data remains unchanged.","text":"Amundsen Seas Low (ASL) highly dynamic mobile climatological low pressure system located Pacific sector Southern Ocean. sector, variability sea-level pressure greater anywhere Southern Hemisphere, making challenging isolate local fluctuations ASL larger-scale shifts atmospheric pressure. position strength ASL crucial understanding regional change West Antarctica (Hosking et al. 2016).","code":""},{"path":[]},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/articles/butterfly_paper.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"butterfly: An R package for the verification of continually updating timeseries data where we expect new values, but want to ensure previous data remains unchanged.","text":"Andersson, T., & Hosking, J. (2021). Forecasts, neural networks, results paper: ‘Seasonal Arctic sea ice forecasting probabilistic deep learning’ (Version 1.0) [Data set]. NERC EDS UK Polar Data Centre. https://doi.org/10.5285/71820e7d-c628-4e32-969f-464b7efb187c Andersson, T.R., Hosking, J.S., Pérez-Ortiz, M. et al. Seasonal Arctic sea ice forecasting probabilistic deep learning. Nat Commun 12, 5124 (2021). https://doi.org/10.1038/s41467-021-25257-4 Blair, Gordon S., Peter . Henrys. 2023. “Role Data Science Environmental Digital Twins: Praise Arrows.” Environmetrics 34 (January): available. https://doi.org/10.1002/env.2789. Hersbach, H., Bell, B., Berrisford, P., Biavati, G., Horányi, ., Muñoz Sabater, J., Nicolas, J., Peubey, C., Radu, R., Rozum, ., Schepers, D., Simmons, ., Soci, C., Dee, D., Thépaut, J-N. (2023): ERA5 hourly data single levels 1940 present. Copernicus Climate Change Service (C3S) Climate Data Store (CDS), DOI: 10.24381/cds.adbb2d47 Hosking, J. S., . Orr, T. J. Bracegirdle, J. Turner (2016), Future circulation changes West Antarctica: Sensitivity Amundsen Sea Low projected anthropogenic forcing, Geophys. Res. Lett., 43, 367–376, doi:10.1002/2015GL067143. Klump, J., Wyborn, L., Wu, M., Martin, J., Downs, R.R. Asmi, . (2021) ‘Versioning Data Revisions: Conceptual Framework Proposed Principles’, Data Science Journal, 20(1), p. 12. Available : https://doi.org/10.5334/dsj-2021-012. Preston-Werner, T. 2013. Semantic Versioning 2.0.0. Semantic Versioning. Available https://semver.org/spec/v2.0.0.html [Last accessed 28 October 2024]. Siddorn, John, Gordon Shaw Blair, David Boot, Justin James Henry Buck, Andrew Kingdon, et al. 2022. “Information Management Framework Environmental Digital Twins (IMFe).” Zenodo. https://doi.org/10.5281/ZENODO.7004351. Tazi, K. (2023). Downscaled ERA5 monthly precipitation data using Multi-Fidelity Gaussian Processes 1980 2012 Upper Beas Sutlej Basins, Himalayas (Version 1.0) [Data set]. NERC EDS UK Polar Data Centre. https://doi.org/10.5285/b2099787-b57c-44ae-bf42-0d46d9ec87cc Wilkinson, Mark D., Michel Dumontier, IJsbrand Jan Aalbersberg, Gabrielle Appleton, Myles Axton, et al. 2016. “FAIR Guiding Principles Scientific Data Management Stewardship.” Scientific Data 3 (1). https://doi.org/10.1038/sdata.2016.18.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Thomas Zwagerman. Author, maintainer.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Thomas Z (2024). “butterfly: quality assurance continually updating overwritten time-series data.”","code":"@Misc{,   title = {{butterfly}: quality assurance of continually updating and overwritten time-series data},   author = {Zwagerman Thomas},   year = {2024}, }"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"butterfly-","dir":"","previous_headings":"","what":"Verification For Continually Updating Timeseries Data","title":"Verification For Continually Updating Timeseries Data","text":"goal butterfly aid verification continually updating overwritten time-series data, expect new values time, want ensure previous data remains unchanged. illustration continually updating timeseries data previous value unexpectedly changes. Data previously recorded change number reasons, discovery error model code, change methodology instrument recalibration. Monitoring data sources changes always possible. Unnoticed changes previous data unintended consequences, invalidating published dataset’s Digital Object Identfier (DOI), altering future predictions used input forecasting models. package provides functionality can used part data pipeline, check flag changes previous data prevent changes going unnoticed.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Verification For Continually Updating Timeseries Data","text":"can install development version butterfly GitHub :","code":"# install.packages(\"devtools\") devtools::install_github(\"thomaszwagerman/butterfly\")"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"overview","dir":"","previous_headings":"","what":"Overview","title":"Verification For Continually Updating Timeseries Data","text":"butterfly package contains following: butterfly::loupe() - examines detail whether previous values changed, returns TRUE/FALSE change/change. butterfly::catch() - returns rows contain previously changed values dataframe. butterfly::release() - drops rows contain previously changed values, returns dataframe containing new unchanged rows. butterfly::create_object_list() - returns list objects required loupe(), catch() release(). Contains underlying functionality. butterfly::timeline() - check timeseries continuous timesteps. butterfly::timeline_group() - group distinct, continuous sequences timeseres. butterflycount - list monthly dataframes, contain fictional butterfly counts given date. forestprecipitation - list monthly dataframes, contain fictional daily precipitation measurements given date.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"examples","dir":"","previous_headings":"","what":"Examples","title":"Verification For Continually Updating Timeseries Data","text":"basic example shows use butterfly: can use butterfly::loupe() examine detail whether previous values changed. butterfly::loupe() uses dplyr::semi_join() match new old objects using common unique identifier, timeseries timestep. waldo::compare() used compare provide detailed report differences. butterfly follows waldo philosophy erring side providing much information, rather little. give detailed feedback message status two objects.","code":"library(butterfly)  # Imagine a continually updated dataset that starts in January and is updated once a month butterflycount$january #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11  # In February an additional row appears, all previous data remains the same butterflycount$february #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55 #> 4 2023-11-01    11  # In March an additional row appears again # ...but a previous value has unexpectedly changed butterflycount$march #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55 #> 5 2023-11-01    18 butterfly::loupe(   butterflycount$february,   butterflycount$january,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data. #> [1] TRUE  butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"using-butterfly-for-data-wrangling","dir":"","previous_headings":"Examples","what":"Using butterfly for data wrangling","title":"Verification For Continually Updating Timeseries Data","text":"might want return changed rows dataframe, drop altogether. butterfly::catch() butterfly::release() provided. , butterfly::catch() returns rows changed previous version. return new rows. Conversely, butterfly::release() drops rows changed previous version. Note retains new rows, expected.","code":"df_caught <- butterfly::catch(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ Only these rows are returned.  df_caught #>         time count #> 1 2023-11-01    18 df_released <- butterfly::release(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17 22 55 18 #> `new$count`: 17 22 55 11 #>  #> ℹ These will be dropped, but new rows are included.  df_released #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55"},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"relevant-packages-and-functions","dir":"","previous_headings":"","what":"Relevant packages and functions","title":"Verification For Continually Updating Timeseries Data","text":"butterfly package created specific use case handling continuously updating/overwritten time-series data, previous values may change without notice. R packages functions handle object comparison, may suit specific needs better. describe overlap differences butterfly: waldo - butterfly uses waldo::compare() every function provide report difference. therefore significant overlap, however butterfly builds waldo providing functionality comparing objects expect changes, previous versions others. butterfly also provides extra user feedback provide clarity isn’t comparing, due nature comparing “matched” rows. diffdf - similar waldo, specifically data frames, diffdf provides ability compare data frames directly. used diffdf::diffdf() case, prefer waldo’s explicit clear user feedback. said, significant overlap functionality: butterfly::loupe() diffdf::diffdf_has_issues() provide TRUE/FALSE difference check, diffdf::diffdf_issue_rows() butterfly::catch() return rows changes occurred. However, lacks flexibility butterfly compare object expect changes, others. assertr - assertr provides assertion functionality can used part pipeline, test assertions particular dataset, offer tools comparison. highly recommend using assertr checks, prior using butterfly, data quality issues caught first. daquiri - daquiri provides tools check data quality visually inspect timeseries data. also quality assurance package timeseries, different purpose butterfly. functions include .equal() (base R) dplyr’s setdiff().","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/index.html","id":"butterfly-in-production","dir":"","previous_headings":"","what":"butterfly in production","title":"Verification For Continually Updating Timeseries Data","text":"Read butterfly used operational data pipeline verify continually updated published dataset.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterfly-package.html","id":null,"dir":"Reference","previous_headings":"","what":"butterfly: Verification For Continually Updating Timeseries Data — butterfly-package","title":"butterfly: Verification For Continually Updating Timeseries Data — butterfly-package","text":"Verification continually updating timeseries data expect new values, want ensure previous data remains unchanged.","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterfly-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"butterfly: Verification For Continually Updating Timeseries Data — butterfly-package","text":"Maintainer: Thomas Zwagerman thozwa@bas.ac.uk (ORCID)","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterflycount.html","id":null,"dir":"Reference","previous_headings":"","what":"Butterfly count dummy data — butterflycount","title":"Butterfly count dummy data — butterflycount","text":"completely fictional dataset monthly butterfly counts","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterflycount.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Butterfly count dummy data — butterflycount","text":"","code":"butterflycount"},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/butterflycount.html","id":"butterflycount","dir":"Reference","previous_headings":"","what":"butterflycount","title":"Butterfly count dummy data — butterflycount","text":"list 4 dataframes (january, february, march, april) containing 3 columns, 3 + n_month rows: time date imaginary count took place, yyyy-mm-dd format count Number fictional butterflies counted species Butterfly species name, appears april","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":null,"dir":"Reference","previous_headings":"","what":"Catch: return dataframe containing only rows that have changed — catch","title":"Catch: return dataframe containing only rows that have changed — catch","text":"function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries), returns new dataframe contains rows changed compared previous data. return new rows.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Catch: return dataframe containing only rows that have changed — catch","text":"","code":"catch(df_current, df_previous, datetime_variable, ...)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Catch: return dataframe containing only rows that have changed — catch","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable. ... waldo::compare() arguments can supplied , tolerance max_diffs. See ?waldo::compare() full list.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Catch: return dataframe containing only rows that have changed — catch","text":"dataframe contains rows df_current changes df_previous, without new rows. Also returns waldo object loupe().","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Catch: return dataframe containing only rows that have changed — catch","text":"underlying functionality handled create_object_list().","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/catch.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Catch: return dataframe containing only rows that have changed — catch","text":"","code":"# Returning only matched rows which contain changes df_caught <- butterfly::catch(   butterflycount$march, # New or current dataset   butterflycount$february, # Previous version you are comparing it to   datetime_variable = \"time\" # Unique ID variable they have in common ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #>  #> ℹ Only these rows are returned.  df_caught #>         time count #> 1 2023-11-01    18"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":null,"dir":"Reference","previous_headings":"","what":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"function creates list objects used loupe(), catch() release().","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"","code":"create_object_list(df_current, df_previous, datetime_variable, ...)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable. ... waldo::compare() arguments can supplied , tolerance max_diffs. See ?waldo::compare() full list.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"list containing boolean TRUE indicates changes previous data FALSE indicates unexpected changes, dataframe current data without new rows dataframe new rows ","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries). informs user new (unmatched) rows appeared, returns waldo::compare() call give detailed breakdown changes. main assumption df_current df_previous newer older versions data, datetime_variable variable name always remains . Elsewhere new columns can appear, returned report.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/create_object_list.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"create_object_list: creates a list of objects used in all butterfly functions — create_object_list","text":"","code":"butterfly_object_list <- butterfly::create_object_list(   butterflycount$february, # New or current dataset   butterflycount$january, # Previous version you are comparing to   datetime_variable = \"time\" # Unique ID variable they have in common ) #> The following rows are new in 'butterflycount$february':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data.  butterfly_object_list #> $butterfly_status #> [1] TRUE #>  #> $df_current_without_new_row #>         time count #> 1 2024-01-01    22 #> 2 2023-12-01    55 #> 3 2023-11-01    11 #>  #> $df_current_new_rows #>         time count #> 1 2024-02-01    17 #>   # You can pass other `waldo::compare()` options such as tolerance here butterfly_object_list <- butterfly::create_object_list(   butterflycount$march, # New or current dataset   butterflycount$february, # Previous version you are comparing it to   datetime_variable = \"time\", # Unique ID variable they have in common   tolerance = 2 ) #> The following rows are new in 'butterflycount$march':  #>         time count #> 1 2024-03-01    23 #> ✔ And there are no differences with previous data.  butterfly_object_list #> $butterfly_status #> [1] TRUE #>  #> $df_current_without_new_row #>         time count #> 1 2024-02-01    17 #> 2 2024-01-01    22 #> 3 2023-12-01    55 #> 4 2023-11-01    18 #>  #> $df_current_new_rows #>         time count #> 1 2024-03-01    23 #>"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/forestprecipitation.html","id":null,"dir":"Reference","previous_headings":"","what":"Forest precipitation dummy data — forestprecipitation","title":"Forest precipitation dummy data — forestprecipitation","text":"completely fictional dataset daily precipitation","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/forestprecipitation.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Forest precipitation dummy data — forestprecipitation","text":"","code":"forestprecipitation"},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/forestprecipitation.html","id":"butterflycount","dir":"Reference","previous_headings":"","what":"butterflycount","title":"Forest precipitation dummy data — forestprecipitation","text":"list 2 dataframes (january, february) containing 2 columns, 6 rows. February intentionally resets 1970-01-01 time date imaginary rainfall measured took place, yyyy-mm-dd format rainfall_mm Rainfall mm","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":null,"dir":"Reference","previous_headings":"","what":"Loupe: compare new and old data in continuously updated timeseries — loupe","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"loupe simple, small magnification device used examine small details closely.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"","code":"loupe(df_current, df_previous, datetime_variable, ...)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable. ... waldo::compare() arguments can supplied , tolerance max_diffs. See ?waldo::compare() full list.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"boolean TRUE indicates changes previous data FALSE indicates unexpected changes.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"function intended aid verification continually updating timeseries data expect new values want ensure previous values remains unchanged. function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries). informs user new (unmatched) rows appeared, returns waldo::compare() call give detailed breakdown changes. main assumption df_current df_previous newer older versions data, datetime_variable variable name always remains . Elsewhere new columns can appear, returned report. underlying functionality handled create_object_list().","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/loupe.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Loupe: compare new and old data in continuously updated timeseries — loupe","text":"","code":"# Checking two dataframes for changes # Returning TRUE (no changes) or FALSE (changes) # This example contains no differences with previous data butterfly::loupe(   butterflycount$february, # New or current dataset   butterflycount$january, # Previous version you are comparing it to   datetime_variable = \"time\" # Unique ID variable they have in common ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-02-01    17 #> ✔ And there are no differences with previous data. #> [1] TRUE  # This example does contain differences with previous data butterfly::loupe(   butterflycount$march,   butterflycount$february,   datetime_variable = \"time\" ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":null,"dir":"Reference","previous_headings":"","what":"Release: return current dataframe without changed old rows — release","title":"Release: return current dataframe without changed old rows — release","text":"function matches two dataframe objects unique identifier (usually \"time\" \"datetime timeseries), returns new dataframe contains new rows (present) matched rows contain changes previous data dropped.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Release: return current dataframe without changed old rows — release","text":"","code":"release(df_current, df_previous, datetime_variable, include_new = TRUE, ...)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Release: return current dataframe without changed old rows — release","text":"df_current data.frame, newest/current version dataset x. df_previous data.frame, old version dataset, example x - t1. datetime_variable string, variable use unique ID join df_current df_previous. Usually \"datetime\" variable. include_new boolean, new rows included? Default TRUE. ... waldo::compare() arguments can supplied , tolerance max_diffs. See ?waldo::compare() full list.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Release: return current dataframe without changed old rows — release","text":"dataframe contains rows df_current changed df_previous, includes new rows. Also returns waldo object loupe().","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/release.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Release: return current dataframe without changed old rows — release","text":"","code":"# Dropping matched rows which contain changes, and returning unchanged rows df_released <- butterfly::release(   butterflycount$march, # New or current dataset   butterflycount$february, # Previous version you are comparing it to   datetime_variable = \"time\", # Unique ID variable they have in common   include_new = TRUE # Whether to include new rows or not, default is TRUE ) #> The following rows are new in 'df_current':  #>         time count #> 1 2024-03-01    23 #>  #> ℹ The following values have changes from the previous data. #> old vs new #>            count #>   old[1, ]    17 #>   old[2, ]    22 #>   old[3, ]    55 #> - old[4, ]    18 #> + new[4, ]    11 #>  #> `old$count`: 17.0 22.0 55.0 18.0 #> `new$count`: 17.0 22.0 55.0 11.0 #>  #> ℹ These will be dropped, but new rows are included.  df_released #>         time count #> 1 2024-03-01    23 #> 2 2024-02-01    17 #> 3 2024-01-01    22 #> 4 2023-12-01    55"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline.html","id":null,"dir":"Reference","previous_headings":"","what":"timeline: check if a timeseries is continuous — timeline","title":"timeline: check if a timeseries is continuous — timeline","text":"Check timeseries continuous. Even timeseries contain obvious gaps, automatically mean also continuous.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"timeline: check if a timeseries is continuous — timeline","text":"","code":"timeline(df_current, datetime_variable, expected_lag = 1)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"timeline: check if a timeseries is continuous — timeline","text":"df_current data.frame, newest/current version dataset x. datetime_variable string, \"datetime\" variable checked continuity. expected_lag numeric, acceptable difference timestep timeseries classed continuous. difference greater expected_lag indicate timeseries continuous. Default 1. smallest units measurement present column used. column formatted YYYY-MM-DD day used.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"timeline: check if a timeseries is continuous — timeline","text":"boolean, TRUE timeseries continuous, FALSE one continuous timeseries within dataset.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"timeline: check if a timeseries is continuous — timeline","text":"Measuring instruments can different behaviours fail. example, power failure internal clock reset \"1970-01-01\", manufacturing date (say, \"2021-01-01\"). leads unpredictable ways checking dataset continuous. timeline_group() timeline() functions attempt give user control check continuity providing expected_lag. difference timesteps dataset exceed expected_lag.","code":""},{"path":[]},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"timeline: check if a timeseries is continuous — timeline","text":"","code":"# A nice continuous dataset should return TRUE butterfly::timeline(   forestprecipitation$january,   datetime_variable = \"time\",   expected_lag = 1 ) #> ✔ There are no time lags which are greater than the expected lag: 1 days. By this measure, the timeseries is continuous. #> [1] TRUE  # In February, our imaginary rain gauge's onboard computer had a failure. # The timestamp was reset to 1970-01-01 butterfly::timeline(   forestprecipitation$february,   datetime_variable = \"time\",   expected_lag = 1 ) #> ℹ There are time lags which are greater than the expected lag: 1 days. This indicates the timeseries is not continuous. There are 2 distinct continuous sequences. Use `timeline_group()` to extract. #> [1] FALSE"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline_group.html","id":null,"dir":"Reference","previous_headings":"","what":"timeline_group: check if a timeseries is continuous — timeline_group","title":"timeline_group: check if a timeseries is continuous — timeline_group","text":"using timeline() established timeseries continuous, working data expect distinct sequences events, can use timeline_group() extract classify different distinct continuous chunks data.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline_group.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"timeline_group: check if a timeseries is continuous — timeline_group","text":"","code":"timeline_group(df_current, datetime_variable, expected_lag = 1)"},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline_group.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"timeline_group: check if a timeseries is continuous — timeline_group","text":"df_current data.frame, newest/current version dataset x. datetime_variable string, \"datetime\" variable checked continuity. expected_lag numeric, acceptable difference timestep timeseries classed continuous. difference greater expected_lag indicate timeseries continuous. Default 1. smallest units measurement present column used. column formatted YYYY-MM-DD day used.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline_group.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"timeline_group: check if a timeseries is continuous — timeline_group","text":"data.frame, identical df_current, extra columns timeline_group, assigns number continuous sets data timelag specifies time lags rows.","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline_group.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"timeline_group: check if a timeseries is continuous — timeline_group","text":"attempt without sorting, changing data couple reasons: difference dates: instruments might record dates appear identical, still chronological order. example, high-frequency data fractional seconds. rare use case though. Dates generally ascending/descending, instrument returned origin. Probably common, results non-continuous dataset, however records still chronological order something like discover. accounted logic case_when().","code":""},{"path":"https://thomaszwagerman.github.io/butterfly/reference/timeline_group.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"timeline_group: check if a timeseries is continuous — timeline_group","text":"","code":"# A nice continuous dataset should return TRUE # In February, our imaginary rain gauge's onboard computer had a failure. # The timestamp was reset to 1970-01-01  # We want to group these different distinct continuous sequences: butterfly::timeline_group(   forestprecipitation$february,   datetime_variable = \"time\",   expected_lag = 1 ) #>                  time rainfall_mm        timelag timeline_group #> 1 2024-02-01 00:00:00         1.1        NA days              1 #> 2 2024-02-02 00:00:00         0.0      1.00 days              1 #> 3 2024-02-03 00:00:00         1.4      1.00 days              1 #> 4 2024-02-04 00:00:00         2.2      1.00 days              1 #> 5 1969-12-31 23:00:00         3.4 -19757.04 days              2 #> 6 1970-01-01 23:00:00         0.6      1.00 days              2"},{"path":"https://thomaszwagerman.github.io/butterfly/news/index.html","id":"butterfly-100","dir":"Changelog","previous_headings":"","what":"butterfly 1.0.0","title":"butterfly 1.0.0","text":"Initial release: butterfly::loupe() - examines detail whether previous values changed, returns TRUE/FALSE change/change. butterfly::catch() - returns rows contain previously changed values dataframe. butterfly::release() - drops rows contain previously changed values, returns dataframe containing new unchanged rows. butterfly::create_object_list() - returns list objects required loupe(), catch() release(). Contains underlying functionality. butterflycount - list monthly dataframes, contain fictional butterfly counts given date.","code":""}]
